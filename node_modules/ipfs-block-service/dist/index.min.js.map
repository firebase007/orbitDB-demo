{"version":3,"sources":["file:webpack/universalModuleDefinition","file:webpack/bootstrap","file:/home/vmx/src/pl/js-ipfs-block-service/src/index.js","file:/home/vmx/src/pl/js-ipfs-block-service/node_modules/streaming-iterables/dist/index-esm.js","file:/home/vmx/src/pl/js-ipfs-block-service/node_modules/process/browser.js","file:/home/vmx/src/pl/js-ipfs-block-service/node_modules/err-code/index.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","map","require","errcode","constructor","ipfsRepo","this","_repo","_bitswap","setExchange","bitswap","unsetExchange","hasExchange","put","block","options","blocks","putMany","cid","getMany","cids","Array","isArray","Error","getRepoBlocks","has","delete","deleteMany","repo","__values","iterator","next","length","done","__await","v","__asyncGenerator","thisArg","_arguments","generator","asyncIterator","TypeError","g","apply","q","verb","Promise","a","b","push","resume","resolve","then","fulfill","reject","settle","e","f","shift","__asyncDelegator","__asyncValues","getIterator","iterable","defer","promise","resolveFunc","rejectFunc","_buffer","size","resultQueue","readQueue","reading","ended","async","fillQueue","error","readDeferred","undefined","fulfillReadQueue","asyncIterableIterator","deferred","buffer","curriedIterable","valueQueue","syncBuffer","_filter","filterFunc","arguments","e_1","_a","iterable_1_1","iterable_1","data","e_1_1","return","filter","flatten","maybeItr","_map","func","val","onceReadable","stream","once","pipeline","firstFn","fns","previousFn","parallelMap","concurrency","curriedFunc","transformError","itr","source","source_1_1","source_1","_parallelMap","_asyncTap","addTime","seconds","nanoseconds","remainder","_writeToStream","lastError","errCb","drainCb","notifyError","err","notifyDrain","write","removeListener","batch","dataBatch","_batch","_syncBatch","collect","values","_collect","from","concat","iterables","find","iterables_1_1","iterables_1","_concat","_syncConcat","consume","_consume","flatMap","flatTransform","inflightCount","itrValue","_c","_b","asyncVal","mapAndQueue","_flatTransform","fromStream","read","_readableState","_fromStream","merge","sources","Set","nextVal","parallelFlatMap","parallelMerge","inputs","concurrentWork","Map","valueCb","notifyDone","queueNext","input","set","add","reduce","start","curriedStart","nextItem","_reduce","take","count","taken","_take","_syncTake","tap","time","config","total","process","hrtime","delta","progress","_asyncTime","_syncTime","transform","_transform","writeToStream","for","cachedSetTimeout","cachedClearTimeout","defaultSetTimout","defaultClearTimeout","runTimeout","fun","setTimeout","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","drainQueue","timeout","len","run","marker","runClearTimeout","Item","array","noop","nextTick","args","title","browser","env","argv","version","versions","on","addListener","off","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","dir","umask","code","props"],"mappings":"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","file":"index.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"IpfsBlockService\"] = factory();\n\telse\n\t\troot[\"IpfsBlockService\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","'use strict'\n\nconst { map } = require('streaming-iterables')\nconst errcode = require('err-code')\n\n/**\n * BlockService is a hybrid block datastore. It stores data in a local\n * datastore and may retrieve data from a remote Exchange.\n * It uses an internal `datastore.Datastore` instance to store values.\n */\nclass BlockService {\n  /**\n   * Create a new BlockService\n   *\n   * @param {IPFSRepo} ipfsRepo\n   */\n  constructor (ipfsRepo) {\n    this._repo = ipfsRepo\n    this._bitswap = null\n  }\n\n  /**\n   * Add a bitswap instance that communicates with the\n   * network to retreive blocks that are not in the local store.\n   *\n   * If the node is online all requests for blocks first\n   * check locally and afterwards ask the network for the blocks.\n   *\n   * @param {Bitswap} bitswap\n   * @returns {void}\n   */\n  setExchange (bitswap) {\n    this._bitswap = bitswap\n  }\n\n  /**\n   * Go offline, i.e. drop the reference to bitswap.\n   *\n   * @returns {void}\n   */\n  unsetExchange () {\n    this._bitswap = null\n  }\n\n  /**\n   * Is the blockservice online, i.e. is bitswap present.\n   *\n   * @returns {bool}\n   */\n  hasExchange () {\n    return this._bitswap != null\n  }\n\n  /**\n   * Put a block to the underlying datastore.\n   *\n   * @param {Block} block\n   * @param {Object} [options] -  Options is an object with the following properties\n   * @param {AbortSignal} [options.signal] - A signal that can be used to abort any long-lived operations that are started as a result of this operation\n   * @returns {Promise}\n   */\n  put (block, options) {\n    if (this.hasExchange()) {\n      return this._bitswap.put(block, options)\n    } else {\n      return this._repo.blocks.put(block, options)\n    }\n  }\n\n  /**\n   * Put a multiple blocks to the underlying datastore.\n   *\n   * @param {AsyncIterator<Block>} blocks\n   * @param {Object} [options] -  Options is an object with the following properties\n   * @param {AbortSignal} [options.signal] - A signal that can be used to abort any long-lived operations that are started as a result of this operation\n   * @returns {Promise}\n   */\n  putMany (blocks, options) {\n    if (this.hasExchange()) {\n      return this._bitswap.putMany(blocks, options)\n    } else {\n      return this._repo.blocks.putMany(blocks, options)\n    }\n  }\n\n  /**\n   * Get a block by cid.\n   *\n   * @param {CID} cid\n   * @param {Object} [options] -  Options is an object with the following properties\n   * @param {AbortSignal} [options.signal] - A signal that can be used to abort any long-lived operations that are started as a result of this operation\n   * @returns {Promise<Block>}\n   */\n  get (cid, options) {\n    if (this.hasExchange()) {\n      return this._bitswap.get(cid, options)\n    } else {\n      return this._repo.blocks.get(cid, options)\n    }\n  }\n\n  /**\n   * Get multiple blocks back from an array of cids.\n   *\n   * @param {AsyncIterator<CID>} cids\n   * @param {Object} [options] -  Options is an object with the following properties\n   * @param {AbortSignal} [options.signal] - A signal that can be used to abort any long-lived operations that are started as a result of this operation\n   * @returns {AsyncIterator<Block>}\n   */\n  getMany (cids, options) {\n    if (!Array.isArray(cids)) {\n      throw new Error('first arg must be an array of cids')\n    }\n\n    if (this.hasExchange()) {\n      return this._bitswap.getMany(cids, options)\n    } else {\n      const getRepoBlocks = map((cid) => this._repo.blocks.get(cid, options))\n      return getRepoBlocks(cids)\n    }\n  }\n\n  /**\n   * Delete a block from the blockstore.\n   *\n   * @param {CID} cid\n   * @param {Object} [options] -  Options is an object with the following properties\n   * @param {AbortSignal} [options.signal] - A signal that can be used to abort any long-lived operations that are started as a result of this operation\n   * @returns {Promise}\n   */\n  async delete (cid, options) {\n    if (!await this._repo.blocks.has(cid)) {\n      throw errcode(new Error('blockstore: block not found'), 'ERR_BLOCK_NOT_FOUND')\n    }\n\n    return this._repo.blocks.delete(cid, options)\n  }\n\n  /**\n   * Delete multiple blocks from the blockstore.\n   *\n   * @param {AsyncIterator<CID>} cids\n   * @param {Object} [options] -  Options is an object with the following properties\n   * @param {AbortSignal} [options.signal] - A signal that can be used to abort any long-lived operations that are started as a result of this operation\n   * @returns {Promise}\n   */\n  deleteMany (cids, options) {\n    const repo = this._repo\n\n    return this._repo.blocks.deleteMany((async function * () {\n      for await (const cid of cids) {\n        if (!await repo.blocks.has(cid)) {\n          throw errcode(new Error('blockstore: block not found'), 'ERR_BLOCK_NOT_FOUND')\n        }\n\n        yield cid\n      }\n    }()), options)\n  }\n}\n\nmodule.exports = BlockService\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.batch = batch;\nexports.buffer = buffer;\nexports.collect = collect;\nexports.concat = concat;\nexports.consume = consume;\nexports.filter = filter;\nexports.flatMap = flatMap;\nexports.flatten = flatten;\nexports.flatTransform = flatTransform;\nexports.fromStream = fromStream;\nexports.getIterator = getIterator;\nexports.map = map;\nexports.merge = merge;\nexports.parallelFlatMap = parallelFlatMap;\nexports.parallelMap = parallelMap;\nexports.parallelMerge = parallelMerge;\nexports.pipeline = pipeline;\nexports.reduce = reduce;\nexports.take = take;\nexports.tap = tap;\nexports.time = time;\nexports.transform = transform;\nexports.writeToStream = writeToStream;\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\nfunction __values(o) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator],\n      i = 0;\n  if (m) return m.call(o);\n  return {\n    next: function next() {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n}\n\nfunction __await(v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\n\nfunction __asyncGenerator(thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []),\n      i,\n      q = [];\n  return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () {\n    return this;\n  }, i;\n\n  function verb(n) {\n    if (g[n]) i[n] = function (v) {\n      return new Promise(function (a, b) {\n        q.push([n, v, a, b]) > 1 || resume(n, v);\n      });\n    };\n  }\n\n  function resume(n, v) {\n    try {\n      step(g[n](v));\n    } catch (e) {\n      settle(q[0][3], e);\n    }\n  }\n\n  function step(r) {\n    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n  }\n\n  function fulfill(value) {\n    resume(\"next\", value);\n  }\n\n  function reject(value) {\n    resume(\"throw\", value);\n  }\n\n  function settle(f, v) {\n    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);\n  }\n}\n\nfunction __asyncDelegator(o) {\n  var i, p;\n  return i = {}, verb(\"next\"), verb(\"throw\", function (e) {\n    throw e;\n  }), verb(\"return\"), i[Symbol.iterator] = function () {\n    return this;\n  }, i;\n\n  function verb(n, f) {\n    i[n] = o[n] ? function (v) {\n      return (p = !p) ? {\n        value: __await(o[n](v)),\n        done: n === \"return\"\n      } : f ? f(v) : v;\n    } : f;\n  }\n}\n\nfunction __asyncValues(o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator],\n      i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () {\n    return this;\n  }, i);\n\n  function verb(n) {\n    i[n] = o[n] && function (v) {\n      return new Promise(function (resolve, reject) {\n        v = o[n](v), settle(resolve, reject, v.done, v.value);\n      });\n    };\n  }\n\n  function settle(resolve, reject, d, v) {\n    Promise.resolve(v).then(function (v) {\n      resolve({\n        value: v,\n        done: d\n      });\n    }, reject);\n  }\n}\n\nfunction _batch(size, iterable) {\n  return __asyncGenerator(this, arguments, function* _batch_1() {\n    var e_1, _a;\n\n    let dataBatch = [];\n\n    try {\n      for (var iterable_1 = __asyncValues(iterable), iterable_1_1; iterable_1_1 = yield __await(iterable_1.next()), !iterable_1_1.done;) {\n        const data = iterable_1_1.value;\n        dataBatch.push(data);\n\n        if (dataBatch.length === size) {\n          yield yield __await(dataBatch);\n          dataBatch = [];\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) yield __await(_a.call(iterable_1));\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    if (dataBatch.length > 0) {\n      yield yield __await(dataBatch);\n    }\n  });\n}\n\nfunction* _syncBatch(size, iterable) {\n  let dataBatch = [];\n\n  for (const data of iterable) {\n    dataBatch.push(data);\n\n    if (dataBatch.length === size) {\n      yield dataBatch;\n      dataBatch = [];\n    }\n  }\n\n  if (dataBatch.length > 0) {\n    yield dataBatch;\n  }\n}\n\nfunction batch(size, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => batch(size, curriedIterable);\n  }\n\n  if (iterable[Symbol.asyncIterator]) {\n    return _batch(size, iterable);\n  }\n\n  return _syncBatch(size, iterable);\n}\n\nfunction getIterator(iterable) {\n  if (typeof iterable.next === 'function') {\n    return iterable;\n  }\n\n  if (typeof iterable[Symbol.iterator] === 'function') {\n    return iterable[Symbol.iterator]();\n  }\n\n  if (typeof iterable[Symbol.asyncIterator] === 'function') {\n    return iterable[Symbol.asyncIterator]();\n  }\n\n  throw new TypeError('\"values\" does not to conform to any of the iterator or iterable protocols');\n}\n\nfunction defer() {\n  let reject;\n  let resolve;\n  const promise = new Promise((resolveFunc, rejectFunc) => {\n    resolve = resolveFunc;\n    reject = rejectFunc;\n  });\n  return {\n    promise,\n    reject,\n    resolve\n  };\n} /// <reference lib=\"esnext.asynciterable\" />\n\n\nfunction _buffer(size, iterable) {\n  const iterator = getIterator(iterable);\n  const resultQueue = [];\n  const readQueue = [];\n  let reading = false;\n  let ended = false;\n\n  function fulfillReadQueue() {\n    while (readQueue.length > 0 && resultQueue.length > 0) {\n      const readDeferred = readQueue.shift();\n      const {\n        error,\n        value\n      } = resultQueue.shift();\n\n      if (error) {\n        readDeferred.reject(error);\n      } else {\n        readDeferred.resolve({\n          done: false,\n          value\n        });\n      }\n    }\n\n    while (readQueue.length > 0 && ended) {\n      const {\n        resolve\n      } = readQueue.shift();\n      resolve({\n        done: true,\n        value: undefined\n      });\n    }\n  }\n\n  async function fillQueue() {\n    if (ended) {\n      return;\n    }\n\n    if (reading) {\n      return;\n    }\n\n    if (resultQueue.length >= size) {\n      return;\n    }\n\n    reading = true;\n\n    try {\n      const {\n        done,\n        value\n      } = await iterator.next();\n\n      if (done) {\n        ended = true;\n      } else {\n        resultQueue.push({\n          value\n        });\n      }\n    } catch (error) {\n      ended = true;\n      resultQueue.push({\n        error\n      });\n    }\n\n    fulfillReadQueue();\n    reading = false;\n    fillQueue();\n  }\n\n  async function next() {\n    if (resultQueue.length > 0) {\n      const {\n        error,\n        value\n      } = resultQueue.shift();\n\n      if (error) {\n        throw error;\n      }\n\n      fillQueue();\n      return {\n        done: false,\n        value\n      };\n    }\n\n    if (ended) {\n      return {\n        done: true,\n        value: undefined\n      }; // stupid ts\n    }\n\n    const deferred = defer();\n    readQueue.push(deferred);\n    fillQueue();\n    return deferred.promise;\n  }\n\n  const asyncIterableIterator = {\n    next,\n    [Symbol.asyncIterator]: () => asyncIterableIterator\n  };\n  return asyncIterableIterator;\n}\n\nfunction* syncBuffer(size, iterable) {\n  const valueQueue = [];\n  let e;\n\n  try {\n    for (const value of iterable) {\n      valueQueue.push(value);\n\n      if (valueQueue.length <= size) {\n        continue;\n      }\n\n      yield valueQueue.shift();\n    }\n  } catch (error) {\n    e = error;\n  }\n\n  for (const value of valueQueue) {\n    yield value;\n  }\n\n  if (e) {\n    throw e;\n  }\n}\n\nfunction buffer(size, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => buffer(size, curriedIterable);\n  }\n\n  if (iterable[Symbol.asyncIterator]) {\n    return _buffer(size, iterable);\n  }\n\n  return syncBuffer(size, iterable);\n}\n\nasync function _collect(iterable) {\n  var e_1, _a;\n\n  const values = [];\n\n  try {\n    for (var iterable_1 = __asyncValues(iterable), iterable_1_1; iterable_1_1 = await iterable_1.next(), !iterable_1_1.done;) {\n      const value = iterable_1_1.value;\n      values.push(value);\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) await _a.call(iterable_1);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n\n  return values;\n}\n\nfunction collect(iterable) {\n  if (iterable[Symbol.asyncIterator]) {\n    return _collect(iterable);\n  }\n\n  return Array.from(iterable);\n}\n\nfunction _concat(iterables) {\n  return __asyncGenerator(this, arguments, function* _concat_1() {\n    var e_1, _a;\n\n    try {\n      for (var iterables_1 = __asyncValues(iterables), iterables_1_1; iterables_1_1 = yield __await(iterables_1.next()), !iterables_1_1.done;) {\n        const iterable = iterables_1_1.value;\n        yield __await(yield* __asyncDelegator(__asyncValues(iterable)));\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (iterables_1_1 && !iterables_1_1.done && (_a = iterables_1.return)) yield __await(_a.call(iterables_1));\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  });\n}\n\nfunction* _syncConcat(iterables) {\n  for (const iterable of iterables) {\n    yield* iterable;\n  }\n}\n\nfunction concat(...iterables) {\n  const hasAnyAsync = iterables.find(itr => itr[Symbol.asyncIterator] !== undefined);\n\n  if (hasAnyAsync) {\n    return _concat(iterables);\n  } else {\n    return _syncConcat(iterables);\n  }\n}\n\nasync function _consume(iterable) {\n  var e_1, _a;\n\n  try {\n    for (var iterable_1 = __asyncValues(iterable), iterable_1_1; iterable_1_1 = await iterable_1.next(), !iterable_1_1.done;) {\n      const val = iterable_1_1.value;\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) await _a.call(iterable_1);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n}\n\nfunction consume(iterable) {\n  if (iterable[Symbol.asyncIterator]) {\n    return _consume(iterable);\n  }\n}\n\nfunction _filter(filterFunc, iterable) {\n  return __asyncGenerator(this, arguments, function* _filter_1() {\n    var e_1, _a;\n\n    try {\n      for (var iterable_1 = __asyncValues(iterable), iterable_1_1; iterable_1_1 = yield __await(iterable_1.next()), !iterable_1_1.done;) {\n        const data = iterable_1_1.value;\n\n        if (yield __await(filterFunc(data))) {\n          yield yield __await(data);\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) yield __await(_a.call(iterable_1));\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  });\n}\n\nfunction filter(filterFunc, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => _filter(filterFunc, curriedIterable);\n  }\n\n  return _filter(filterFunc, iterable);\n}\n\nfunction flatten(iterable) {\n  return __asyncGenerator(this, arguments, function* flatten_1() {\n    var e_1, _a;\n\n    try {\n      for (var iterable_1 = __asyncValues(iterable), iterable_1_1; iterable_1_1 = yield __await(iterable_1.next()), !iterable_1_1.done;) {\n        const maybeItr = iterable_1_1.value;\n\n        if (maybeItr && typeof maybeItr !== 'string' && (maybeItr[Symbol.iterator] || maybeItr[Symbol.asyncIterator])) {\n          yield __await(yield* __asyncDelegator(__asyncValues(flatten(maybeItr))));\n        } else {\n          yield yield __await(maybeItr);\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) yield __await(_a.call(iterable_1));\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  });\n}\n\nfunction _map(func, iterable) {\n  return __asyncGenerator(this, arguments, function* _map_1() {\n    var e_1, _a;\n\n    try {\n      for (var iterable_1 = __asyncValues(iterable), iterable_1_1; iterable_1_1 = yield __await(iterable_1.next()), !iterable_1_1.done;) {\n        const val = iterable_1_1.value;\n        yield yield __await(yield __await(func(val)));\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) yield __await(_a.call(iterable_1));\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  });\n}\n\nfunction map(func, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => _map(func, curriedIterable);\n  }\n\n  return _map(func, iterable);\n}\n\nfunction flatMap(func, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => flatMap(func, curriedIterable);\n  }\n\n  return filter(i => i !== undefined && i !== null, flatten(map(func, iterable)));\n}\n\nfunction _flatTransform(concurrency, func, iterable) {\n  const iterator = getIterator(iterable);\n  const resultQueue = [];\n  const readQueue = [];\n  let ended = false;\n  let reading = false;\n  let inflightCount = 0;\n  let lastError = null;\n\n  function fulfillReadQueue() {\n    while (readQueue.length > 0 && resultQueue.length > 0) {\n      const {\n        resolve\n      } = readQueue.shift();\n      const value = resultQueue.shift();\n      resolve({\n        done: false,\n        value\n      });\n    }\n\n    while (readQueue.length > 0 && inflightCount === 0 && ended) {\n      const {\n        resolve,\n        reject\n      } = readQueue.shift();\n\n      if (lastError) {\n        reject(lastError);\n        lastError = null;\n      } else {\n        resolve({\n          done: true,\n          value: undefined\n        });\n      }\n    }\n  }\n\n  async function fillQueue() {\n    if (ended) {\n      fulfillReadQueue();\n      return;\n    }\n\n    if (reading) {\n      return;\n    }\n\n    if (inflightCount + resultQueue.length >= concurrency) {\n      return;\n    }\n\n    reading = true;\n    inflightCount++;\n\n    try {\n      const {\n        done,\n        value\n      } = await iterator.next();\n\n      if (done) {\n        ended = true;\n        inflightCount--;\n        fulfillReadQueue();\n      } else {\n        mapAndQueue(value);\n      }\n    } catch (error) {\n      ended = true;\n      inflightCount--;\n      lastError = error;\n      fulfillReadQueue();\n    }\n\n    reading = false;\n    fillQueue();\n  }\n\n  async function mapAndQueue(itrValue) {\n    var e_1, _a;\n\n    try {\n      const value = await func(itrValue);\n\n      if (value && value[Symbol.asyncIterator]) {\n        try {\n          for (var _b = __asyncValues(value), _c; _c = await _b.next(), !_c.done;) {\n            const asyncVal = _c.value;\n            resultQueue.push(asyncVal);\n          }\n        } catch (e_1_1) {\n          e_1 = {\n            error: e_1_1\n          };\n        } finally {\n          try {\n            if (_c && !_c.done && (_a = _b.return)) await _a.call(_b);\n          } finally {\n            if (e_1) throw e_1.error;\n          }\n        }\n      } else {\n        resultQueue.push(value);\n      }\n    } catch (error) {\n      ended = true;\n      lastError = error;\n    }\n\n    inflightCount--;\n    fulfillReadQueue();\n    fillQueue();\n  }\n\n  async function next() {\n    if (resultQueue.length === 0) {\n      const deferred = defer();\n      readQueue.push(deferred);\n      fillQueue();\n      return deferred.promise;\n    }\n\n    const value = resultQueue.shift();\n    fillQueue();\n    return {\n      done: false,\n      value\n    };\n  }\n\n  const asyncIterableIterator = {\n    next,\n    [Symbol.asyncIterator]: () => asyncIterableIterator\n  };\n  return asyncIterableIterator;\n}\n\nfunction flatTransform(concurrency, func, iterable) {\n  if (func === undefined) {\n    return (curriedFunc, curriedIterable) => curriedIterable ? flatTransform(concurrency, curriedFunc, curriedIterable) : flatTransform(concurrency, curriedFunc);\n  }\n\n  if (iterable === undefined) {\n    return curriedIterable => flatTransform(concurrency, func, curriedIterable);\n  }\n\n  return filter(i => i !== undefined && i !== null, flatten(_flatTransform(concurrency, func, iterable)));\n}\n\nasync function onceReadable(stream) {\n  return new Promise(resolve => {\n    stream.once('readable', () => {\n      resolve();\n    });\n  });\n}\n\nfunction _fromStream(stream) {\n  return __asyncGenerator(this, arguments, function* _fromStream_1() {\n    while (true) {\n      const data = stream.read();\n\n      if (data !== null) {\n        yield yield __await(data);\n        continue;\n      }\n\n      if (stream._readableState.ended) {\n        return yield __await(void 0);\n      }\n\n      yield __await(onceReadable(stream));\n    }\n  });\n}\n\nfunction fromStream(stream) {\n  if (typeof stream[Symbol.asyncIterator] === 'function') {\n    return stream;\n  }\n\n  return _fromStream(stream);\n}\n\nfunction merge(...iterables) {\n  return __asyncGenerator(this, arguments, function* merge_1() {\n    const sources = new Set(iterables.map(getIterator));\n\n    while (sources.size > 0) {\n      for (const iterator of sources) {\n        const nextVal = yield __await(iterator.next());\n\n        if (nextVal.done) {\n          sources.delete(iterator);\n        } else {\n          yield yield __await(nextVal.value);\n        }\n      }\n    }\n  });\n}\n\nfunction pipeline(firstFn, ...fns) {\n  let previousFn = firstFn();\n\n  for (const func of fns) {\n    previousFn = func(previousFn);\n  }\n\n  return previousFn;\n}\n\nfunction _parallelMap(concurrency, func, iterable) {\n  return __asyncGenerator(this, arguments, function* _parallelMap_1() {\n    let transformError = null;\n\n    const wrapFunc = value => ({\n      value: func(value)\n    });\n\n    const stopOnError = function stopOnError(source) {\n      return __asyncGenerator(this, arguments, function* () {\n        var e_1, _a;\n\n        try {\n          for (var source_1 = __asyncValues(source), source_1_1; source_1_1 = yield __await(source_1.next()), !source_1_1.done;) {\n            const value = source_1_1.value;\n\n            if (transformError) {\n              return yield __await(void 0);\n            }\n\n            yield yield __await(value);\n          }\n        } catch (e_1_1) {\n          e_1 = {\n            error: e_1_1\n          };\n        } finally {\n          try {\n            if (source_1_1 && !source_1_1.done && (_a = source_1.return)) yield __await(_a.call(source_1));\n          } finally {\n            if (e_1) throw e_1.error;\n          }\n        }\n      });\n    };\n\n    const output = pipeline(() => iterable, buffer(1), stopOnError, map(wrapFunc), buffer(concurrency));\n    const itr = getIterator(output);\n\n    while (true) {\n      const {\n        value,\n        done\n      } = yield __await(itr.next());\n\n      if (done) {\n        break;\n      }\n\n      try {\n        const val = yield __await(value.value);\n\n        if (!transformError) {\n          yield yield __await(val);\n        }\n      } catch (error) {\n        transformError = error;\n      }\n    }\n\n    if (transformError) {\n      throw transformError;\n    }\n  });\n}\n\nfunction parallelMap(concurrency, func, iterable) {\n  if (func === undefined) {\n    return (curriedFunc, curriedIterable) => parallelMap(concurrency, curriedFunc, curriedIterable);\n  }\n\n  if (iterable === undefined) {\n    return curriedIterable => parallelMap(concurrency, func, curriedIterable);\n  }\n\n  return _parallelMap(concurrency, func, iterable);\n}\n\nfunction parallelFlatMap(concurrency, func, iterable) {\n  if (func === undefined) {\n    return (curriedFunc, curriedIterable) => curriedIterable ? parallelFlatMap(concurrency, curriedFunc, curriedIterable) : parallelFlatMap(concurrency, curriedFunc);\n  }\n\n  if (iterable === undefined) {\n    return curriedIterable => parallelFlatMap(concurrency, func, curriedIterable);\n  }\n\n  return filter(i => i !== undefined && i !== null, flatten(parallelMap(concurrency, func, iterable)));\n}\n\nfunction parallelMerge(...iterables) {\n  return __asyncGenerator(this, arguments, function* parallelMerge_1() {\n    const inputs = iterables.map(getIterator);\n    const concurrentWork = new Set();\n    const values = new Map();\n    let lastError = null;\n    let errCb = null;\n    let valueCb = null;\n\n    const notifyError = err => {\n      lastError = err;\n\n      if (errCb) {\n        errCb(err);\n      }\n    };\n\n    const notifyDone = value => {\n      if (valueCb) {\n        valueCb(value);\n      }\n    };\n\n    const waitForQueue = () => new Promise((resolve, reject) => {\n      if (lastError) {\n        reject(lastError);\n      }\n\n      if (values.size > 0) {\n        return resolve();\n      }\n\n      valueCb = resolve;\n      errCb = reject;\n    });\n\n    const queueNext = input => {\n      const nextVal = Promise.resolve(input.next()).then(async ({\n        done,\n        value\n      }) => {\n        if (!done) {\n          values.set(input, value);\n        }\n\n        concurrentWork.delete(nextVal);\n      });\n      concurrentWork.add(nextVal);\n      nextVal.then(notifyDone, notifyError);\n    };\n\n    for (const input of inputs) {\n      queueNext(input);\n    }\n\n    while (true) {\n      // We technically don't have to check `values.size` as the for loop should have emptied it\n      // However I haven't yet found specs verifying that behavior, only tests\n      // the guard in waitForQueue() checking for values is in place for the same reason\n      if (concurrentWork.size === 0 && values.size === 0) {\n        return yield __await(void 0);\n      }\n\n      yield __await(waitForQueue());\n\n      for (const [input, value] of values) {\n        values.delete(input);\n        yield yield __await(value);\n        queueNext(input);\n      }\n    }\n  });\n}\n\nasync function _reduce(func, start, iterable) {\n  var e_1, _a;\n\n  let value = start;\n\n  try {\n    for (var iterable_1 = __asyncValues(iterable), iterable_1_1; iterable_1_1 = await iterable_1.next(), !iterable_1_1.done;) {\n      const nextItem = iterable_1_1.value;\n      value = await func(value, nextItem);\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) await _a.call(iterable_1);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n\n  return value;\n}\n\nfunction reduce(func, start, iterable) {\n  if (start === undefined) {\n    return (curriedStart, curriedIterable) => curriedIterable ? reduce(func, curriedStart, curriedIterable) : reduce(func, curriedStart);\n  }\n\n  if (iterable === undefined) {\n    return curriedIterable => reduce(func, start, curriedIterable);\n  }\n\n  return _reduce(func, start, iterable);\n}\n\nfunction _take(count, iterable) {\n  return __asyncGenerator(this, arguments, function* _take_1() {\n    var e_1, _a;\n\n    let taken = 0;\n\n    try {\n      for (var iterable_1 = __asyncValues(iterable), iterable_1_1; iterable_1_1 = yield __await(iterable_1.next()), !iterable_1_1.done;) {\n        const val = iterable_1_1.value;\n        yield yield __await(yield __await(val));\n        taken++;\n\n        if (taken >= count) {\n          return yield __await(void 0);\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) yield __await(_a.call(iterable_1));\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  });\n}\n\nfunction* _syncTake(count, iterable) {\n  let taken = 0;\n\n  for (const val of iterable) {\n    yield val;\n    taken++;\n\n    if (taken >= count) {\n      return;\n    }\n  }\n}\n\nfunction take(count, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => take(count, curriedIterable);\n  }\n\n  if (iterable[Symbol.asyncIterator]) {\n    return _take(count, iterable);\n  }\n\n  return _syncTake(count, iterable);\n}\n\nfunction _asyncTap(func, iterable) {\n  return __asyncGenerator(this, arguments, function* _asyncTap_1() {\n    var e_1, _a;\n\n    try {\n      for (var iterable_1 = __asyncValues(iterable), iterable_1_1; iterable_1_1 = yield __await(iterable_1.next()), !iterable_1_1.done;) {\n        const val = iterable_1_1.value;\n        yield __await(func(val));\n        yield yield __await(val);\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) yield __await(_a.call(iterable_1));\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  });\n}\n\nfunction tap(func, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => _asyncTap(func, curriedIterable);\n  }\n\n  return _asyncTap(func, iterable);\n}\n\nfunction addTime(a, b) {\n  let seconds = a[0] + b[0];\n  let nanoseconds = a[1] + b[1];\n\n  if (nanoseconds >= 1000000000) {\n    const remainder = nanoseconds % 1000000000;\n    seconds += (nanoseconds - remainder) / 1000000000;\n    nanoseconds = remainder;\n  }\n\n  return [seconds, nanoseconds];\n}\n\nfunction _asyncTime(config, iterable) {\n  return __asyncGenerator(this, arguments, function* _asyncTime_1() {\n    const itr = iterable[Symbol.asyncIterator]();\n    let total = [0, 0];\n\n    while (true) {\n      const start = process.hrtime();\n      const {\n        value,\n        done\n      } = yield __await(itr.next());\n      const delta = process.hrtime(start);\n      total = addTime(total, delta);\n\n      if (config.progress) {\n        config.progress(delta, total);\n      }\n\n      if (done) {\n        if (config.total) {\n          config.total(total);\n        }\n\n        return yield __await(value);\n      }\n\n      yield yield __await(value);\n    }\n  });\n}\n\nfunction* _syncTime(config, iterable) {\n  const itr = iterable[Symbol.iterator]();\n  let total = [0, 0];\n\n  while (true) {\n    const start = process.hrtime();\n    const {\n      value,\n      done\n    } = itr.next();\n    const delta = process.hrtime(start);\n    total = addTime(total, delta);\n\n    if (config.progress) {\n      config.progress(delta, total);\n    }\n\n    if (done) {\n      if (config.total) {\n        config.total(total);\n      }\n\n      return value;\n    }\n\n    yield value;\n  }\n}\n\nfunction time(config = {}, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => time(config, curriedIterable);\n  }\n\n  if (iterable[Symbol.asyncIterator] !== undefined) {\n    return _asyncTime(config, iterable);\n  } else {\n    return _syncTime(config, iterable);\n  }\n}\n\nfunction _transform(concurrency, func, iterable) {\n  const iterator = getIterator(iterable);\n  const resultQueue = [];\n  const readQueue = [];\n  let ended = false;\n  let reading = false;\n  let inflightCount = 0;\n  let lastError = null;\n\n  function fulfillReadQueue() {\n    while (readQueue.length > 0 && resultQueue.length > 0) {\n      const {\n        resolve\n      } = readQueue.shift();\n      const value = resultQueue.shift();\n      resolve({\n        done: false,\n        value\n      });\n    }\n\n    while (readQueue.length > 0 && inflightCount === 0 && ended) {\n      const {\n        resolve,\n        reject\n      } = readQueue.shift();\n\n      if (lastError) {\n        reject(lastError);\n        lastError = null;\n      } else {\n        resolve({\n          done: true,\n          value: undefined\n        });\n      }\n    }\n  }\n\n  async function fillQueue() {\n    if (ended) {\n      fulfillReadQueue();\n      return;\n    }\n\n    if (reading) {\n      return;\n    }\n\n    if (inflightCount + resultQueue.length >= concurrency) {\n      return;\n    }\n\n    reading = true;\n    inflightCount++;\n\n    try {\n      const {\n        done,\n        value\n      } = await iterator.next();\n\n      if (done) {\n        ended = true;\n        inflightCount--;\n        fulfillReadQueue();\n      } else {\n        mapAndQueue(value);\n      }\n    } catch (error) {\n      ended = true;\n      inflightCount--;\n      lastError = error;\n      fulfillReadQueue();\n    }\n\n    reading = false;\n    fillQueue();\n  }\n\n  async function mapAndQueue(itrValue) {\n    try {\n      const value = await func(itrValue);\n      resultQueue.push(value);\n    } catch (error) {\n      ended = true;\n      lastError = error;\n    }\n\n    inflightCount--;\n    fulfillReadQueue();\n    fillQueue();\n  }\n\n  async function next() {\n    if (resultQueue.length === 0) {\n      const deferred = defer();\n      readQueue.push(deferred);\n      fillQueue();\n      return deferred.promise;\n    }\n\n    const value = resultQueue.shift();\n    fillQueue();\n    return {\n      done: false,\n      value\n    };\n  }\n\n  const asyncIterableIterator = {\n    next,\n    [Symbol.asyncIterator]: () => asyncIterableIterator\n  };\n  return asyncIterableIterator;\n}\n\nfunction transform(concurrency, func, iterable) {\n  if (func === undefined) {\n    return (curriedFunc, curriedIterable) => curriedIterable ? transform(concurrency, curriedFunc, curriedIterable) : transform(concurrency, curriedFunc);\n  }\n\n  if (iterable === undefined) {\n    return curriedIterable => transform(concurrency, func, curriedIterable);\n  }\n\n  return _transform(concurrency, func, iterable);\n}\n\nasync function _writeToStream(stream, iterable) {\n  var e_1, _a;\n\n  let lastError = null;\n  let errCb = null;\n  let drainCb = null;\n\n  const notifyError = err => {\n    lastError = err;\n\n    if (errCb) {\n      errCb(err);\n    }\n  };\n\n  const notifyDrain = () => {\n    if (drainCb) {\n      drainCb();\n    }\n  };\n\n  const cleanup = () => {\n    stream.removeListener('error', notifyError);\n    stream.removeListener('drain', notifyDrain);\n  };\n\n  stream.once('error', notifyError);\n\n  const waitForDrain = () => new Promise((resolve, reject) => {\n    if (lastError) {\n      return reject(lastError);\n    }\n\n    stream.once('drain', notifyDrain);\n    drainCb = resolve;\n    errCb = reject;\n  });\n\n  try {\n    for (var iterable_1 = __asyncValues(iterable), iterable_1_1; iterable_1_1 = await iterable_1.next(), !iterable_1_1.done;) {\n      const value = iterable_1_1.value;\n\n      if (stream.write(value) === false) {\n        await waitForDrain();\n      }\n\n      if (lastError) {\n        break;\n      }\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) await _a.call(iterable_1);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n\n  cleanup();\n\n  if (lastError) {\n    throw lastError;\n  }\n}\n\nfunction writeToStream(stream, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => _writeToStream(stream, curriedIterable);\n  }\n\n  return _writeToStream(stream, iterable);\n} /// <reference lib=\"esnext.asynciterable\" />\n\n\nif (Symbol.asyncIterator === undefined) {\n  Symbol.asyncIterator = Symbol.for('asyncIterator');\n}","\"use strict\";\n\n// shim for using process in browser\nvar process = module.exports = {}; // cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n  throw new Error('setTimeout has not been defined');\n}\n\nfunction defaultClearTimeout() {\n  throw new Error('clearTimeout has not been defined');\n}\n\n(function () {\n  try {\n    if (typeof setTimeout === 'function') {\n      cachedSetTimeout = setTimeout;\n    } else {\n      cachedSetTimeout = defaultSetTimout;\n    }\n  } catch (e) {\n    cachedSetTimeout = defaultSetTimout;\n  }\n\n  try {\n    if (typeof clearTimeout === 'function') {\n      cachedClearTimeout = clearTimeout;\n    } else {\n      cachedClearTimeout = defaultClearTimeout;\n    }\n  } catch (e) {\n    cachedClearTimeout = defaultClearTimeout;\n  }\n})();\n\nfunction runTimeout(fun) {\n  if (cachedSetTimeout === setTimeout) {\n    //normal enviroments in sane situations\n    return setTimeout(fun, 0);\n  } // if setTimeout wasn't available but was latter defined\n\n\n  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n    cachedSetTimeout = setTimeout;\n    return setTimeout(fun, 0);\n  }\n\n  try {\n    // when when somebody has screwed with setTimeout but no I.E. maddness\n    return cachedSetTimeout(fun, 0);\n  } catch (e) {\n    try {\n      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n      return cachedSetTimeout.call(null, fun, 0);\n    } catch (e) {\n      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n      return cachedSetTimeout.call(this, fun, 0);\n    }\n  }\n}\n\nfunction runClearTimeout(marker) {\n  if (cachedClearTimeout === clearTimeout) {\n    //normal enviroments in sane situations\n    return clearTimeout(marker);\n  } // if clearTimeout wasn't available but was latter defined\n\n\n  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n    cachedClearTimeout = clearTimeout;\n    return clearTimeout(marker);\n  }\n\n  try {\n    // when when somebody has screwed with setTimeout but no I.E. maddness\n    return cachedClearTimeout(marker);\n  } catch (e) {\n    try {\n      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n      return cachedClearTimeout.call(null, marker);\n    } catch (e) {\n      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n      // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n      return cachedClearTimeout.call(this, marker);\n    }\n  }\n}\n\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n  if (!draining || !currentQueue) {\n    return;\n  }\n\n  draining = false;\n\n  if (currentQueue.length) {\n    queue = currentQueue.concat(queue);\n  } else {\n    queueIndex = -1;\n  }\n\n  if (queue.length) {\n    drainQueue();\n  }\n}\n\nfunction drainQueue() {\n  if (draining) {\n    return;\n  }\n\n  var timeout = runTimeout(cleanUpNextTick);\n  draining = true;\n  var len = queue.length;\n\n  while (len) {\n    currentQueue = queue;\n    queue = [];\n\n    while (++queueIndex < len) {\n      if (currentQueue) {\n        currentQueue[queueIndex].run();\n      }\n    }\n\n    queueIndex = -1;\n    len = queue.length;\n  }\n\n  currentQueue = null;\n  draining = false;\n  runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n  var args = new Array(arguments.length - 1);\n\n  if (arguments.length > 1) {\n    for (var i = 1; i < arguments.length; i++) {\n      args[i - 1] = arguments[i];\n    }\n  }\n\n  queue.push(new Item(fun, args));\n\n  if (queue.length === 1 && !draining) {\n    runTimeout(drainQueue);\n  }\n}; // v8 likes predictible objects\n\n\nfunction Item(fun, array) {\n  this.fun = fun;\n  this.array = array;\n}\n\nItem.prototype.run = function () {\n  this.fun.apply(null, this.array);\n};\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\n\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) {\n  return [];\n};\n\nprocess.binding = function (name) {\n  throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () {\n  return '/';\n};\n\nprocess.chdir = function (dir) {\n  throw new Error('process.chdir is not supported');\n};\n\nprocess.umask = function () {\n  return 0;\n};","'use strict';\n\nfunction createError(err, code, props) {\n  var key;\n\n  if (!(err instanceof Error)) {\n    throw new TypeError('Please pass an Error to err-code');\n  }\n\n  if (typeof code === 'object') {\n    props = code;\n  } else if (code != null) {\n    err.code = code;\n  }\n\n  if (props) {\n    for (key in props) {\n      err[key] = props[key];\n    }\n  }\n\n  return err;\n}\n\nmodule.exports = createError;"],"sourceRoot":""}